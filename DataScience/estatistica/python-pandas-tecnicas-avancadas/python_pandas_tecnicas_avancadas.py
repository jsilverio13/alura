# -*- coding: utf-8 -*-
"""python-pandas-tecnicas-avancadas.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1F5FVNfMh20hUze2ly_MZDHFUCuLin39C

# PANDAS AVANÇADO
---

# CARREGANDO OS DADOS
---

## Configurações do projeto

### Importando pacotes
"""

import pandas as pd

pd.__version__

"""### Opções de configuração

[Documentação](https://pandas.pydata.org/pandas-docs/stable/user_guide/options.html)
"""

pd.get_option('display.max_rows')

pd.get_option('display.max_columns')

"""[Opções disponíveis](https://pandas.pydata.org/pandas-docs/stable/user_guide/options.html#available-options)"""

pd.describe_option()

pd.describe_option('display.max_rows')

import numpy as np

df = pd.DataFrame(np.arange(10000).reshape(100, 100))
df

pd.set_option('display.max_rows', 100)
pd.set_option('display.max_columns', 100)

df

pd.reset_option('display.max_rows')
pd.reset_option('display.max_columns')
df

"""## Carregando os dados

### Arquivos JSON - `read_json`

[Documentação](https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.read_json.html)

## JSON

JSON (**J**ava**S**cript **O**bject **N**otation - Notação de Objetos JavaScript) é uma formatação leve de troca de dados. Para seres humanos, é fácil de ler e escrever. Para máquinas, é fácil de interpretar e gerar. Está baseado em um subconjunto da linguagem de programação JavaScript, Standard ECMA-262 3a Edição - Dezembro - 1999. JSON é em formato texto e completamente independente de linguagem, pois usa convenções que são familiares às linguagens C e familiares, incluindo C++, C#, Java, JavaScript, Perl, Python e muitas outras. Estas propriedades fazem com que JSON seja um formato ideal de troca de dados.

[fonte](https://www.json.org/json-pt.html)

[Online JSON Viewer](http://jsonviewer.stack.hu/)
"""

data_json = '{"A": [1,2,3,4], "B": [5,6,7,8], "C": [9,10,11,12]}'
data_json

dados = pd.read_json(
    path_or_buf = data_json,
    orient='index'
)

dados

dados = pd.read_json(
    path_or_buf = 'realestates.json',
    orient='columns'
)

dados

"""### Arquivos EXCEL - `read_excel`

[Documentação](https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.read_excel.html)
"""

bairros = pd.read_excel(
    io = 'bairros.xlsx',
    sheet_name='Preço médio por tipo',
    usecols='C:E',
    header = 2,
    index_col=[0,1],
    names=['bairros', 'tipo', 'valor_m2_bairro']
)

bairros

"""# TRANSFORMANDO E TRATANDO OS DADOS
---

## Transformando dados no formato JSON para uma tabela
"""

dados

"""### `json_normalize`

[Documentação](https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.json_normalize.html)
"""

dados_normal = pd.json_normalize(data=dados.normal)
dados_normal

dados_normal['listings'].iloc[0]

type(dados_normal['listings'].iloc[0])

len(dados_normal['listings'].iloc[0])

dados_normal_listing = pd.json_normalize(data=dados_normal['listings'].iloc[0], sep='_', max_level=2)
dados_normal_listing

dados_normal_listing = pd.json_normalize(data=dados.normal, sep='_', record_path=['listings'])
dados_normal_listing

dados_highlights_listing = pd.json_normalize(data=dados.highlights, sep='_', record_path=['listings'])
dados_highlights_listing

"""## Trabalhando com dados textuais

### Transformando *strings* em listas do Python
"""

dados_normal_listing.head(2)

lista_str = dados_normal_listing.loc[0, 'imovel_caracteristicas_propriedade']
lista_str

type(lista_str)

"""#### Métodos de *strings*

[Documentação](https://docs.python.org/3.6/library/stdtypes.html#string-methods)
"""

lista_str[1:-1]

lista_str.strip('[]')

lista_str[1:-1].replace("'", "")

lista = lista_str[1:-1].replace("'", "").split(", ")
lista

type(lista)

texto = dados_normal_listing.loc[:, 'imovel_caracteristicas_propriedade']
texto

"""#### `str`

[Documentação](https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.Series.str.html)
"""

texto.str

texto.str[1:-1]

texto.str[1:-1].str.replace("'", "")

texto.str[1:-1].str.replace("'", "").str.split(", ")

texto = texto.str[1:-1].str.replace("'", "").str.split(", ")
texto

type(texto[0])

"""#### `filter`

[Documentação](https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.DataFrame.filter.html)
"""

columns = dados_normal_listing.filter(like='imovel_caracteristicas').columns

for column in columns:
  print(column)
  dados_normal_listing[column] = dados_normal_listing[column].str[1:-1].str.replace("'", "").str.split(", ")
  dados_highlights_listing[column] = dados_highlights_listing[column].str[1:-1].str.replace("'", "").str.split(", ")

dados_normal_listing.loc[0, 'imovel_caracteristicas_propriedade'][0]

"""# COMBINANDO CONJUNTOS DE DADOS
---
"""

dados_normal_listing.columns ==  dados_highlights_listing.columns

"""## Empilhando *DataFrames*

### `append`

[Documentação](https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.DataFrame.append.html)
"""

dados_normal_listing.append(dados_highlights_listing)

dados_normal_listing.append(dados_highlights_listing, ignore_index=True)

dados_listings = dados_normal_listing.append(dados_highlights_listing, ignore_index=True)

dados_listings

"""### `concat`

[Documentação](https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.concat.html)
"""

dados_listings = pd.concat([dados_normal_listing, dados_highlights_listing], ignore_index=True)

dados_listings

"""## Combinando *DataFrames* a partir de uma chave de ligação"""

bairros

"""### Tratando a variável de ligação

#### Selecionando a variável de ligação nos dois *DataFrames*
"""

bairros_amostra = dados_listings['imovel_endereco_bairro']
bairros_amostra

"""[Documentação: `get_level_values`](https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.MultiIndex.get_level_values.html)"""

bairros_todos = bairros.index.get_level_values('bairros')
bairros_todos

"""#### Identificando e eliminando valores duplicados - `nunique` e `unique`

[Documentação: `nunique`](https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.Series.nunique.html)

[Documentação: `unique`](https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.Series.unique.html)
"""

bairros_amostra.shape

bairros_amostra.nunique()

bairros_amostra.unique()

type(bairros_amostra.unique())

bairros_amostra = pd.Series(bairros_amostra.unique())
bairros_amostra

"""---"""

bairros_todos.shape

bairros_todos.nunique()

bairros_todos = pd.Series(bairros_todos.unique())
bairros_todos

"""#### Verificando se existe correspondência entre as variáveis de ligação

[Documentação](https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.Series.isin.html)
"""

bairros_amostra

bairros_amostra.isin(bairros_todos)

bairros.loc['Freguesia']

bairros.loc['Jacarepaguá']

"""#### Ajustando os valores

[Documentação](https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.Series.replace.html)
"""

dados_listings['imovel_endereco_bairro'].replace('Freguesia (Jacarepaguá)', 'Freguesia', inplace = True)

bairros_amostra = pd.Series(dados_listings['imovel_endereco_bairro'].unique())

bairros_amostra.isin(bairros_todos)

"""### Combinando os *DataFrames*

#### `merge`

[Documentação](https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.merge.html)

```
pandas.merge(left, right, how='inner', on=None, left_on=None, right_on=None, left_index=False, right_index=False, sort=False, suffixes='_x', '_y', copy=True, indicator=False, validate=None)
```

**Parameters**

- **left**: DataFrame


- **right**: DataFrame
    

- **how**: {‘left’, ‘right’, ‘outer’, ‘inner’}, *default* ‘inner’

        Tipo de junção que será realizada.

        - left: usa apenas as chaves do DataFrame especificado no parâmetro left.

        - right: usa apenas as chaves do DataFrame especificado no parâmetro right.

        - outer: considera todos os registros dos DataFrames especificados nos parâmetros left e right, isto é, faz a união das chaves.

        - inner: considera apenas a interseção das chaves dos DataFrames especificados nos parâmetros left e right.
    

- **on**: label ou list

        Nomes das colunas ou dos índices que serão utilizados na junção. Estes devem ser encontrados em ambos os DataFrames.
        

- **left_on**: label ou list, or array-like

        Nomes das colunas ou dos índices do DataFrame especificado em left que serão utilizados na junção.
        

- **right_on**: label or list, or array-like

        Nomes das colunas ou dos índices do DataFrame especificado em right que serão utilizados na junção.
    

- **left_index**: bool, *default False*

        Indica se o índice do DataFrame especificado no parâmetro left deve ser utilizado como chave de junção.
        

- **right_index**: bool, *default False*

        Indica se o índice do DataFrame especificado no parâmetro right deve ser utilizado como chave de junção.
"""

dados_listings[['imovel_endereco_bairro', 'imovel_tipos_propriedade']]

bairros

dados_listings = pd.merge(
    left = dados_listings,
    right = bairros,
    left_on = ['imovel_endereco_bairro', 'imovel_tipos_propriedade'],
    right_index = True
)

dados_listings

"""# ADICIONANDO INFORMAÇÕES
---

## Criando as colunas `quartos`, `suites` e `banheiros`
"""

dados_listings['anuncio_descricao'].values[:10]

"""### `str.extractall`

[Documentação](https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.Series.str.extractall.html)
"""

configuracao = dados_listings['anuncio_descricao'].str.extractall('(\d+)')
configuracao

"""### `unstack`

[Documentação](https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.DataFrame.unstack.html)
"""

configuracao = configuracao.unstack().rename(columns={0: 'quartos', 1: 'suite', 2:'banheiros'})
configuracao

"""### `droplevel`

[Documentação](https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.DataFrame.droplevel.html)
"""

configuracao = configuracao.droplevel(level=0, axis=1)
configuracao

dados_listings = pd.merge(dados_listings, configuracao, left_index=True, right_index = True)
dados_listings

"""## Criando novas classificações

### Com dados categóricos - `map`

[Documentação](https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.Series.map.html)
"""

tipo_uso = {
    'Apartamento': 'Residencial',
    'Casa': 'Residencial',
    'Cobertura': 'Residencial',
    'Consultório': 'Comercial',
    'Imóvel Comercial': 'Comercial',
    'Loja': 'Comercial',
    'Sala Comercial': 'Comercial'
}

dados_listings.imovel_tipos_propriedade.map(tipo_uso)

imovel_tipos_uso = dados_listings.imovel_tipos_propriedade.map(tipo_uso)

"""#### `insert`

[Documentação](https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.DataFrame.insert.html)
"""

dados_listings.insert(loc=0, column='imovel_tipos_uso', value=imovel_tipos_uso)

dados_listings

"""### Com dados numéricos - `cut`

[Documentação](https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.cut.html)
"""

valor_minimo = dados_listings['anuncio_valores_venda'].min()

valor_maximo = dados_listings['anuncio_valores_venda'].max()

rotulos = ['Popular', 'Padrão', 'Alto Padrão']

"""#### Utilizando classes fixas"""

pd.cut(x=dados_listings['anuncio_valores_venda'], bins=3, labels=rotulos)

"""#### Utilizando classes personalizadas"""

classes = [valor_minimo, 400000, 2000000, valor_maximo]

pd.cut(x=dados_listings['anuncio_valores_venda'], bins=classes, labels=rotulos, include_lowest=True)

dados_listings['classe_valor'] = pd.cut(x=dados_listings['anuncio_valores_venda'], bins=classes, labels=rotulos, include_lowest=True)

dados_listings

"""## Novas colunas derivadas das informações existentes

### Valor por m²
"""

dados_listings['valor_m2'] = dados_listings['anuncio_valores_venda'] / dados_listings['imovel_area']

dados_listings[['anuncio_valores_venda','imovel_area','valor_m2']].iloc[16:19]

"""#### `apply`

[Documentação](https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.DataFrame.apply.html)
"""

valor_m2 = lambda data: data['anuncio_valores_venda'] / data['imovel_area'] if data['imovel_area'] !=0 else 0

dados_listings['valor_m2'] = dados_listings.apply(valor_m2, axis=1)

dados_listings[['anuncio_valores_venda','imovel_area','valor_m2']].iloc[16:19]

"""### Piscina?"""

dados_listings['Piscina'] = dados_listings['imovel_caracteristicas_condominio'].apply(lambda x: 'Piscina' in x)
dados_listings[['imovel_caracteristicas_condominio', 'Piscina']].head()

pd.set_option('display.max_colwidth', None)

dados_listings[['imovel_caracteristicas_condominio', 'Piscina']].head()

"""# TABULAÇÕES E SUMARIZAÇÕES
---

## Agrupamentos

### `aggregate`

[Documentação](https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.DataFrame.aggregate.html)
"""

dados_listings[['anuncio_valores_venda', 'anuncio_valores_condominio', 'anuncio_valores_iptu']].aggregate(['sum','mean','std'])

dados_listings[['anuncio_valores_venda', 'anuncio_valores_condominio', 'anuncio_valores_iptu']].agg(['sum','mean','std'])

"""### `groupby`

[Documentação](https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.DataFrame.groupby.html)
"""

agrupamento = dados_listings[['imovel_tipos_propriedade','valor_m2']].groupby(by='imovel_tipos_propriedade')

agrupamento.mean().round()

agrupamento.agg(func=['min', 'mean','max','std'])

agrupamento = dados_listings[['imovel_tipos_propriedade','classe_valor','valor_m2']].groupby(by=['imovel_tipos_propriedade', 'classe_valor'])

agrupamento.mean().round()

agrupamento.agg(func=['min', 'mean','max','std'])

"""### `value_counts`

[Documentação](https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.DataFrame.value_counts.html)
"""

dados_listings.value_counts(subset='imovel_tipos_propriedade')

dados_listings.value_counts(subset='imovel_tipos_propriedade',normalize=True)

dados_listings.value_counts(subset=['imovel_tipos_propriedade', 'classe_valor'])

"""#### `to_frame`

[Documentação](https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.Series.to_frame.html)
"""

dados_listings.value_counts(subset=['imovel_tipos_propriedade', 'classe_valor']).to_frame(name='Quantidade')

"""## Mudando o formato de um *DataFrame*

### `unstack`

Faz a rotação ou o pivoteamento das linhas para as colunas.

[Documentação](https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.DataFrame.unstack.html)
"""

bairros.unstack(level=0)

bairros.unstack(level=-1)

"""### `stack`

Faz a rotação ou o pivoteamento das colunas de um *DataFrame* para as linhas.

[Documentação](https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.DataFrame.stack.html)
"""

agrupamento

tabelas_estatisticas = agrupamento.agg(func=['min', 'mean','max','std']).round(2)
tabelas_estatisticas

tabelas_estatisticas = tabelas_estatisticas.stack(dropna=False)
tabelas_estatisticas

tabelas_estatisticas.unstack(level=-2)

"""## Criando tabelas dinâmicas

### `pivot`

[Documentação](https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.DataFrame.pivot.html)
"""

tabelas_estatisticas= agrupamento.agg(func=['min', 'mean','max','std']).round(2)
tabelas_estatisticas

"""#### `droplevel`

[Documentação](https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.DataFrame.droplevel.html)
"""

tabelas_estatisticas = tabelas_estatisticas.droplevel(level=0, axis='columns')
tabelas_estatisticas

"""#### `reset_index`

[Documentação](https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.DataFrame.reset_index.html)
"""

tabelas_estatisticas.reset_index(inplace=True)
tabelas_estatisticas

tabelas_estatisticas.pivot(
    index='imovel_tipos_propriedade',
    columns='classe_valor',
    values='mean'
)

"""### `pivot_table`

[Documentação](https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.DataFrame.pivot_table.html)
"""

dados_listings

dados_listings.pivot_table(
    values='valor_m2',
    index='imovel_tipos_propriedade',
    columns='classe_valor',
    fill_value='-',
    margins=True,
    margins_name='Média Geral',
    aggfunc='mean'
)

dados_listings.pivot_table(
    values='valor_m2',
    index=['imovel_tipos_propriedade','classe_valor'],
    columns=['anuncio_tipos_listagem','Piscina'],
    fill_value='-',
    margins=True,
    margins_name='Média Geral',
    aggfunc='mean',
    dropna=False
)

"""# TABULAÇÕES E ESTILIZAÇÃO
---

## Tabulações a partir de informações no formato de listas

### `explode`

[Documentação](https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.DataFrame.explode.html)
"""

caracteristicas_propiedade = dados_listings['imovel_caracteristicas_propriedade']
caracteristicas_propiedade

caracteristicas_propiedade_itens = caracteristicas_propiedade.explode()
caracteristicas_propiedade_itens

pd.merge(
    left = caracteristicas_propiedade_itens.value_counts(),
    right=caracteristicas_propiedade_itens.value_counts(normalize=True),
    left_index = True,
    right_index = True
)

"""#### `where`

[Documentação](https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.Series.where.html)
"""

caracteristicas_propiedade_itens.where(
    cond=caracteristicas_propiedade_itens!='',
    other='Sem Características',
    inplace=True
)

pd.merge(
    left = caracteristicas_propiedade_itens.value_counts(),
    right=caracteristicas_propiedade_itens.value_counts(normalize=True),
    left_index = True,
    right_index = True
)

"""## Estilizando um DataFrame

### `style`

[Documentação](https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.DataFrame.style.html)
"""

tabela_frequencias = pd.merge(
    left = caracteristicas_propiedade_itens.value_counts(sort=False),
    right=caracteristicas_propiedade_itens.value_counts(normalize=True),
    left_index = True,
    right_index = True
)
tabela_frequencias

tabela_frequencias.query("index != 'Sem Características'", inplace=True)

tabela_frequencias.rename(columns={
    'imovel_caracteristicas_propriedade_x': 'Frequências',
    'imovel_caracteristicas_propriedade_y': 'Percentual'
}, inplace = True)

tabela_frequencias.rename_axis('Características', inplace=True)

tabela_frequencias

"""#### `format`

[Documentação](https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.io.formats.style.Styler.format.html)
"""

tabela_frequencias.style.format({'Percentual':'{:.2%}'})

"""#### `bar`

[Documentação](https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.io.formats.style.Styler.bar.html)
"""

tabela_frequencias.style.format({'Percentual':'{:.2%}'}).bar(subset='Percentual', vmin=0.05, color='lightblue')

"""#### `applymap`

[Documentação](https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.io.formats.style.Styler.applymap.html)
"""

tabela_frequencias.style.format({'Percentual':'{:.2%}'}) \
                        .bar(subset='Percentual', vmin=0.05, color='lightblue') \
                        .applymap(lambda x: f"color: {'red' if x >= 35 else 'black'}", subset='Frequências')

tabela_frequencias.style.format({'Percentual':'{:.2%}'}) \
  .bar(subset='Percentual', vmin=0.05, color='lightblue') \
  .applymap(lambda x: f"color: {'red' if x >= 35 else 'black'}", subset='Frequências') \
  .applymap(lambda x: f"font-weight: {'bold' if x >= 35 else 'normal'}", subset='Frequências')

"""#### `highlight_max` e `highlight_min`

[Documentação: `highlight_max`](https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.io.formats.style.Styler.highlight_max.html)

[Documentação: `highlight_min`](https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.io.formats.style.Styler.highlight_min.html)
"""

bairros

bairros.unstack()

bairros_zona_sul = ['Ipanema', 'Botafogo', 'Catete', 'Copacabana', 'Lagoa', 'Flamengo','Gávea', 'Glória','Jardim Botânico', 'Laranjeiras', 'Leme','Urca', 'Vidigal', 'Cosme Velho', 'São Conrado', 'Leblon']

tabela_zona_sul = bairros.unstack().query("index in " + str(bairros_zona_sul)).droplevel(level=0, axis=1)
tabela_zona_sul

tabela_zona_sul.style.format('R$ {:,.2f}') \
  .highlight_max(color='lightgreen') \
  .highlight_min(color='#C26161')

"""#### `background_gradient`

[Documentação](https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.io.formats.style.Styler.background_gradient.html)
"""

tabela_zona_sul[['Apartamento']].style.format('R$ {:,.2f}') \
  .background_gradient(cmap='Reds')

tabela_zona_sul.style.format('R$ {:,.2f}') \
  .background_gradient(subset=['Apartamento'], cmap='Greens') \
  .background_gradient(subset=['Cobertura'], cmap='Blues')

"""#### `to_excel`

[Documentação](https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.io.formats.style.Styler.to_excel.html)
"""

tabela_zona_sul.style.format('R$ {:,.2f}') \
  .background_gradient(subset=['Apartamento'], cmap='Greens') \
  .background_gradient(subset=['Cobertura'], cmap='Blues') \
  .to_excel('Tabela Zona Sul.xlsx', engine='openpyxl')

"""# ANEXOS
---

### Opções para o parâmetro `cmap`

[Documentação](https://matplotlib.org/3.3.2/tutorials/colors/colormaps.html)
"""

import numpy as np
import matplotlib as mpl
import matplotlib.pyplot as plt
from matplotlib import cm
from collections import OrderedDict

cmaps = OrderedDict()

cmaps['Perceptually Uniform Sequential'] = [
            'viridis', 'plasma', 'inferno', 'magma', 'cividis']

cmaps['Sequential'] = [
            'Greys', 'Purples', 'Blues', 'Greens', 'Oranges', 'Reds',
            'YlOrBr', 'YlOrRd', 'OrRd', 'PuRd', 'RdPu', 'BuPu',
            'GnBu', 'PuBu', 'YlGnBu', 'PuBuGn', 'BuGn', 'YlGn']

cmaps['Sequential (2)'] = [
            'binary', 'gist_yarg', 'gist_gray', 'gray', 'bone', 'pink',
            'spring', 'summer', 'autumn', 'winter', 'cool', 'Wistia',
            'hot', 'afmhot', 'gist_heat', 'copper']

cmaps['Diverging'] = [
            'PiYG', 'PRGn', 'BrBG', 'PuOr', 'RdGy', 'RdBu',
            'RdYlBu', 'RdYlGn', 'Spectral', 'coolwarm', 'bwr', 'seismic']

cmaps['Cyclic'] = ['twilight', 'twilight_shifted', 'hsv']

cmaps['Qualitative'] = ['Pastel1', 'Pastel2', 'Paired', 'Accent',
                        'Dark2', 'Set1', 'Set2', 'Set3',
                        'tab10', 'tab20', 'tab20b', 'tab20c']

cmaps['Miscellaneous'] = [
            'flag', 'prism', 'ocean', 'gist_earth', 'terrain', 'gist_stern',
            'gnuplot', 'gnuplot2', 'CMRmap', 'cubehelix', 'brg',
            'gist_rainbow', 'rainbow', 'jet', 'nipy_spectral',
            'gist_ncar']

nrows = max(len(cmap_list) for cmap_category, cmap_list in cmaps.items())
gradient = np.linspace(0, 1, 256)
gradient = np.vstack((gradient, gradient))


def plot_color_gradients(cmap_category, cmap_list, nrows):
    fig, axes = plt.subplots(nrows=nrows)
    fig.subplots_adjust(top=0.95, bottom=0.01, left=0.2, right=0.99)
    axes[0].set_title(cmap_category + ' colormaps', fontsize=14)

    for ax, name in zip(axes, cmap_list):
        ax.imshow(gradient, aspect='auto', cmap=plt.get_cmap(name))
        pos = list(ax.get_position().bounds)
        x_text = pos[0] - 0.01
        y_text = pos[1] + pos[3]/2.
        fig.text(x_text, y_text, name, va='center', ha='right', fontsize=10)

    # Turn off *all* ticks & spines, not just the ones with colormaps.
    for ax in axes:
        ax.set_axis_off()


for cmap_category, cmap_list in cmaps.items():
    plot_color_gradients(cmap_category, cmap_list, nrows)

plt.show()

