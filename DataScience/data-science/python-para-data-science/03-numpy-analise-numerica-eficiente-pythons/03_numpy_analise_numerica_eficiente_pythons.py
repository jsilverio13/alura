# -*- coding: utf-8 -*-
"""03 - numpy-analise-numerica-eficiente-pythons.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/12fGcfC27qY0KQrOJrR9qef-V9tSMTbO6

# NUMPY - ALURA

A NumPy é uma biblioteca em Python que oferece diversas ferramentas e funcionalidades essenciais para computação científica, incluindo objetos de matriz multidimensional chamados de arrays, rotinas para operações rápidas em matrizes, além de operações matemáticas, manipulação de forma, estatísticas e muito mais. É amplamente utilizado em áreas como análise de dados, processamento de sinais e aprendizado de máquina.

Mais conteúdo sobre as suas funcionalidades pode ser acessado no link: https://numpy.org/devdocs/index.html

# Aula 1

## Vídeo 1.3 - Carregando dados

A versão original da base de dados utilizada neste curso pode encontrada neste [link](https://www.kaggle.com/datasets/kapatsa/apple-prices-in-russian-regions) onde você pode ler um pouco mais sobre o problema e questões em potencial relacionadas a estes dados. 


Porém, neste curso será utilizada uma versão modificada disponível neste [link](https://github.com/alura-cursos/numpy/blob/dados/apples_ts.csv). O link para a versão Raw do arquivo repositório do Github é este: https://raw.githubusercontent.com/alura-cursos/numpy/dados/apples_ts.csv .
"""

import numpy as np

url = 'https://raw.githubusercontent.com/alura-cursos/numpy/dados/apples_ts.csv'

np.arange(1,88,1)

7*12+3

dado = np.loadtxt(url,delimiter=',',usecols=np.arange(1,88,1))

"""## Vídeo 1.4 - Dimensões do array"""

dado.ndim

dado.size

dado.shape

"""### Transposição do array"""

dado.T

dado.T.shape

dado_transposto = dado.T

"""# Aula 2

## Vídeo 2.1 - Visualização e seleção

### *A[ i : j ]*

Recorta a lista *A* do índice i até o j. Neste fatiamento o elemento com índice i é **incluído** e o elemento com índice j **não é incluído** no resultado.
"""

datas = dado_transposto[:,0]

precos = dado_transposto[:,1:6]

"""Matplotlib é uma biblioteca em Python que oferece diversas ferramentas e funcionalidades para a criação de visualizações em gráficos. Ela permite criar gráficos estáticos, animados e interativos de forma simples e oferece recursos avançados para a criação de gráficos mais complexos. É amplamente utilizada em áreas como análise de dados, processamento de sinais e aprendizado de máquina. Neste curso iremos utilizar apenas a plt.plot, mas se você quiser se aprofundar no assunto pode consultar a documentação na biblioteca neste link: https://matplotlib.org/"""

import matplotlib.pyplot as plt

plt.plot(datas, precos[:,0])

datas = np.arange(1,88,1)

plt.plot(datas, precos[:,0])

Moscow = precos[:,0]
Kaliningrad = precos[:,1]
Petersburg = precos[:,2]
Krasnodar = precos[:,3]
Ekaterinburg = precos[:,4]

"""## Vídeo 2.2 - Comparação entre arrays"""

Moscow.shape

Moscow_ano1 = Moscow[0:12]
Moscow_ano2 = Moscow[13:25]
Moscow_ano3 = Moscow[25:37]
Moscow_ano4 = Moscow[37:49]

plt.plot(np.arange(1,13,1), Moscow_ano1)
plt.plot(np.arange(1,13,1), Moscow_ano2)
plt.plot(np.arange(1,13,1), Moscow_ano3)
plt.plot(np.arange(1,13,1), Moscow_ano4)
plt.legend(['ano1','ano2','ano3','ano4'])

np.array_equal(Moscow_ano3, Moscow_ano4)

np.allclose(Moscow_ano3, Moscow_ano4,10)

"""## Vídeo 2.3 - Lidando com NaNs"""

plt.plot(datas, Kaliningrad)

np.isnan(Kaliningrad)

Kaliningrad

sum(np.isnan(Kaliningrad))

(Kaliningrad[3] + Kaliningrad[5])/2

np.mean([Kaliningrad[3], Kaliningrad[5]])

Kaliningrad[4] = np.mean([Kaliningrad[3], Kaliningrad[5]])

np.mean(Moscow)

np.mean(Kaliningrad)

"""# Aula 3 - Operações entre arrays

## Vídeo 3.1 - Diferença entre arrays
"""

plt.plot(datas, Moscow)

"""y = ax+b"""

x= datas

y = 2*x+80

plt.plot(datas, Moscow)
plt.plot(datas, y)

np.sqrt(np.sum(np.power(Moscow - y,2)))

y = 0.52*x+80
plt.plot(datas, Moscow)
plt.plot(datas, y)

Moscow - y

np.sqrt(np.sum(np.power(Moscow - y,2)))

np.linalg.norm(Moscow - y)

"""## Vídeo 3.2 - Multiplicação elemento a elemento

A equação de uma reta na forma y = ax + b é uma expressão matemática que descreve a relação entre os valores de x e y em uma linha reta. O valor de "a" representa a inclinação (ou declive) da reta, que é a taxa de variação entre os valores de x e y. O valor de "b" é o ponto de intercepção no eixo y, ou seja, o valor de y quando x é igual a zero. Com essa equação, é possível plotar a reta em um sistema de coordenadas cartesianas, onde o eixo x representa os valores de x e o eixo y representa os valores de y. A equação da reta é amplamente utilizada em várias áreas da matemática e também em outras áreas, como física e engenharia, para modelar dados e prever comportamentos futuros.

a = Coeficiente angular

n -> número de elementos

Y = Moscow

X = datas



O coefiente angular pode ser obtido usando a equação:

$$ \hat{a} = \frac{n*Soma( X_i*Y_i ) - Soma( X_i )*Soma(Y_i)}{n Soma(X_i^2) - (Soma(X_i))^2}$$
"""

Y = Moscow
X = datas
n = np.size(Moscow)

X.shape

(X**2).shape

a = (n*np.sum(X*Y) - np.sum(X)*np.sum(Y))/(n*np.sum(X**2)-np.sum(X)**2)

"""Coeficiente linear 

$$ \hat{b} = Media(Y_i) - \hat{a} * Media(X_i) $$
"""

b = np.mean(Y) - a*np.mean(X)

y = a*X+b

np.linalg.norm(Moscow - y)

plt.plot(datas, Moscow)
plt.plot(datas, y)

"""## Vídeo 3.3 - Para que serve a regressão linear"""

plt.plot(datas, Moscow)
plt.plot(datas, y)
plt.plot(41.5, a*41.5+b,'*r')
plt.plot(100, a*100+b,'*r')

"""# Aula 4 - Números aleatórios

## Vídeo 4.1 - Valores em um intervalo
"""

np.random.randint(low=40,high=100,size=100)

coef_angulares = np.random.uniform(low=0.10,high=0.90,size=100)

b

norma = np.array([])

for i in range(100):
  norma = np.append(norma,np.linalg.norm(Moscow- (coef_angulares[i]*X+b)))

norma

coef_angulares[3]

"""## Vídeo 4.2 - Reprodutibilidade

Números pseudoaleatórios são sequências de números gerados por algoritmos que tentam imitar o comportamento de sequências aleatórias. Eles não são verdadeiramente aleatórios, mas parecem ser aleatórios o suficiente para muitas aplicações práticas.

Os algoritmos geradores de números pseudoaleatórios geralmente iniciam com uma semente (seed), que é um número inicial que é fornecido como entrada para o algoritmo. A partir da semente, o algoritmo usa operações matemáticas para gerar uma sequência de números aparentemente aleatórios. No entanto, como o algoritmo é determinístico, a sequência de números gerada sempre será a mesma para a mesma semente.
"""

np.random.uniform(low=0.10,high=0.90,size=100)

np.random.seed(16)
np.random.uniform(low=0.10,high=0.90,size=100)

norma = np.array([])
np.random.seed(84)
coef_angulares = np.random.uniform(low=0.10,high=0.90,size=100)

for i in range(100):
  norma = np.append(norma,np.linalg.norm(Moscow- (coef_angulares[i]*X+b)))

"""## Vídeo 4.3 - Salvando os resultados"""

dados = np.column_stack([norma,coef_angulares])

dados.shape

np.savetxt('dados.csv', dados,delimiter=',')